"""Mypy guardrail that fails only on *new* errors.

This lets us turn mypy into a CI gate without requiring fixing the entire existing backlog.

Usage:
  python tools/mypy_gate.py
  python tools/mypy_gate.py --write-baseline
"""

from __future__ import annotations

import argparse
import re
import subprocess
import sys
from collections import Counter
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Optional


ROOT = Path(__file__).resolve().parents[1]
BASELINE_PATH = ROOT / "tools" / "mypy_baseline.txt"


_MYPY_ERROR_RE = re.compile(
    r"""
    ^
    (?P<path>.+?)
    :
    (?P<line>\d+)
    (?:
      :
      (?P<col>\d+)
    )?
    :
    \s+
    (?P<severity>error|note)
    :
    \s+
    (?P<message>.*?)
    (?:\s+\[(?P<code>[a-z0-9-]+)\])?
    $
    """,
    re.VERBOSE,
)


@dataclass(frozen=True)
class MypyIssueKey:
    path: str
    code: str


def _normalize_path(path_text: str) -> str:
    text = path_text.strip().replace("\\", "/")
    if text.startswith("./"):
        text = text[2:]

    # Strip repo root if mypy prints absolute paths (common on Windows or some CI setups)
    root_str = str(ROOT).replace("\\", "/").rstrip("/")
    if text.startswith(root_str + "/"):
        text = text[len(root_str) + 1 :]
    return text


def _run_mypy() -> str:
    cmd = [
        sys.executable,
        "-m",
        "mypy",
        "core/",
        "--exclude",
        "frontend",
        "--exclude",
        "backend",
        "--show-error-codes",
        "--no-color-output",
    ]
    proc = subprocess.run(cmd, cwd=str(ROOT), capture_output=True, text=True)
    return (proc.stdout or "") + (proc.stderr or "")


def _parse_error_keys(mypy_output: str) -> tuple[Counter[MypyIssueKey], dict[MypyIssueKey, str]]:
    counts: Counter[MypyIssueKey] = Counter()
    examples: dict[MypyIssueKey, str] = {}

    for raw_line in mypy_output.splitlines():
        line = raw_line.strip()
        if not line:
            continue

        match = _MYPY_ERROR_RE.match(line)
        if not match:
            continue

        if match.group("severity") != "error":
            continue

        path = _normalize_path(match.group("path"))
        code = match.group("code") or ""

        key = MypyIssueKey(path=path, code=code)
        counts[key] += 1
        examples.setdefault(key, raw_line)

    return counts, examples


def _load_baseline(path: Path) -> Counter[MypyIssueKey]:
    if not path.exists():
        raise FileNotFoundError(f"Baseline file not found: {path}")

    baseline: Counter[MypyIssueKey] = Counter()
    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue

        parts = line.split("\t")
        if len(parts) != 3:
            raise ValueError(f"Invalid baseline line (expected 3 tab-separated fields): {raw_line}")

        count_text, path_text, code_text = parts
        baseline[MypyIssueKey(path=path_text, code=code_text)] = int(count_text)

    return baseline


def _write_baseline(path: Path, counts: Counter[MypyIssueKey]) -> None:
    lines = [
        "# mypy baseline for core/",
        "# Format: count<TAB>path<TAB>error_code",
        "# Generated by: python tools/mypy_gate.py --write-baseline",
        "",
    ]
    for key in sorted(counts.keys(), key=lambda k: (k.path, k.code)):
        lines.append(f"{counts[key]}\t{key.path}\t{key.code}")

    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def _diff_new_errors(
    current: Counter[MypyIssueKey], baseline: Counter[MypyIssueKey]
) -> Counter[MypyIssueKey]:
    new: Counter[MypyIssueKey] = Counter()
    for key, count in current.items():
        baseline_count = baseline.get(key, 0)
        if count > baseline_count:
            new[key] = count - baseline_count
    return new


def main(argv: Optional[Iterable[str]] = None) -> int:  # noqa: UP045
    parser = argparse.ArgumentParser(description="Fail CI only on new mypy errors in core/")
    parser.add_argument(
        "--write-baseline",
        action="store_true",
        help="Write tools/mypy_baseline.txt from current mypy output",
    )
    args = parser.parse_args(list(argv) if argv is not None else None)

    output = _run_mypy()
    current_counts, examples = _parse_error_keys(output)

    if args.write_baseline:
        _write_baseline(BASELINE_PATH, current_counts)
        print(f"Wrote baseline: {BASELINE_PATH}")
        return 0

    baseline_counts = _load_baseline(BASELINE_PATH)
    new = _diff_new_errors(current_counts, baseline_counts)

    if not new:
        print("mypy gate PASSED (no new errors).")
        return 0

    print("mypy gate FAILED (new errors detected):")
    for key in sorted(new.keys(), key=lambda k: (k.path, k.code)):
        count = new[key]
        example = examples.get(key, "")
        suffix = f" (+{count})" if count != 1 else " (+1)"
        print(f"- {key.path} [{key.code}]{suffix}")
        if example:
            print(f"    e.g. {example}")

    print("")
    print(f"Baseline file: {BASELINE_PATH}")
    print("If these errors are expected, regenerate the baseline with:")
    print("  python tools/mypy_gate.py --write-baseline")
    return 1


if __name__ == "__main__":
    raise SystemExit(main())
